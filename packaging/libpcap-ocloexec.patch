--- sf-pcap.c.orig
+++ sf-pcap.c
@@ -550,7 +550,7 @@ pcap_dump_open(pcap_t *p, const char *fn
 		fname = "standard output";
 	} else {
 #if !defined(WIN32) && !defined(MSDOS)
-		f = fopen(fname, "w");
+		f = fopen(fname, "we");
 #else
 		f = fopen(fname, "wb");
 #endif
--- pcap-linux.c.orig
+++ pcap-linux.c
@@ -980,7 +980,7 @@ pcap_can_set_rfmon_linux(pcap_t *handle)
 	 * (We assume that if we have Wireless Extensions support
 	 * we also have PF_PACKET support.)
 	 */
-	sock_fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
+	sock_fd = socket(PF_PACKET, SOCK_RAW|SOCK_CLOEXEC, htons(ETH_P_ALL));
 	if (sock_fd == -1) {
 		(void)snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    "socket: %s", pcap_strerror(errno));
@@ -1508,7 +1508,7 @@ pcap_read_packet(pcap_t *handle, pcap_ha
 		}
 
 #if defined(HAVE_PACKET_AUXDATA) && defined(HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI)
-		packet_len = recvmsg(handle->fd, &msg, MSG_TRUNC);
+		packet_len = recvmsg(handle->fd, &msg, MSG_TRUNC|MSG_CMSG_CLOEXEC);
 #else /* defined(HAVE_PACKET_AUXDATA) && defined(HAVE_LINUX_TPACKET_AUXDATA_TP_VLAN_TCI) */
 		fromlen = sizeof(from);
 		packet_len = recvfrom(
@@ -1976,7 +1976,7 @@ scan_sys_class_net(pcap_if_t **devlistp,
 	/*
 	 * Create a socket from which to fetch interface information.
 	 */
-	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	fd = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, 0);
 	if (fd < 0) {
 		(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    "socket: %s", pcap_strerror(errno));
@@ -2122,7 +2122,7 @@ scan_proc_net_dev(pcap_if_t **devlistp,
 	/*
 	 * Create a socket from which to fetch interface information.
 	 */
-	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	fd = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, 0);
 	if (fd < 0) {
 		(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    "socket: %s", pcap_strerror(errno));
@@ -2919,8 +2919,8 @@ activate_new(pcap_t *handle)
 	 * try a SOCK_RAW socket for the raw interface.
 	 */
 	sock_fd = is_any_device ?
-		socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_ALL)) :
-		socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
+		socket(PF_PACKET, SOCK_DGRAM|SOCK_CLOEXEC, htons(ETH_P_ALL)) :
+		socket(PF_PACKET, SOCK_RAW|SOCK_CLOEXEC, htons(ETH_P_ALL));
 
 	if (sock_fd == -1) {
 		if (errno == EINVAL || errno == EAFNOSUPPORT) {
@@ -3036,7 +3036,7 @@ activate_new(pcap_t *handle)
 					 "close: %s", pcap_strerror(errno));
 				return PCAP_ERROR;
 			}
-			sock_fd = socket(PF_PACKET, SOCK_DGRAM,
+			sock_fd = socket(PF_PACKET, SOCK_DGRAM|SOCK_CLOEXEC,
 			    htons(ETH_P_ALL));
 			if (sock_fd == -1) {
 				snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
@@ -5065,7 +5065,7 @@ activate_old(pcap_t *handle)
 
 	/* Open the socket */
 
-	handle->fd = socket(PF_INET, SOCK_PACKET, htons(ETH_P_ALL));
+	handle->fd = socket(PF_INET, SOCK_PACKET|SOCK_CLOEXEC, htons(ETH_P_ALL));
 	if (handle->fd == -1) {
 		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
 			 "socket: %s", pcap_strerror(errno));
--- configure.in.orig
+++ configure.in
@@ -22,7 +22,9 @@ AC_INIT(pcap.c)
 AC_CANONICAL_SYSTEM
 
 AC_LBL_C_INIT_BEFORE_CC(V_CCOPT, V_INCLS)
-AC_PROG_CC
+AC_PROG_CC_STDC
+AC_USE_SYSTEM_EXTENSIONS
+AC_SYS_LARGEFILE
 AC_LBL_C_INIT(V_CCOPT, V_INCLS)
 AC_LBL_SHLIBS_INIT
 AC_LBL_C_INLINE
--- pcap-canusb-linux.c.orig
+++ pcap-canusb-linux.c
@@ -36,6 +36,7 @@
 #include "config.h"
 #endif
 
+#include <pthread.h>
 #include <libusb-1.0/libusb.h>
 
 #include "pcap-int.h"
@@ -264,7 +265,7 @@ static int canusb_startcapture(struct ca
 {
   int pipefd[2];
 
-  if (pipe(pipefd) == -1) return -1;
+  if (pipe2(pipefd, O_CLOEXEC) == -1) return -1;
 
   canusb.rdpipe = pipefd[0];
   canusb.wrpipe = pipefd[1];
--- inet.c.orig
+++ inet.c
@@ -430,7 +430,7 @@ add_addr_to_iflist(pcap_if_t **alldevs,
 	 */
 	memset(&ifrdesc, 0, sizeof ifrdesc);
 	strlcpy(ifrdesc.ifr_name, name, sizeof ifrdesc.ifr_name);
-	s = socket(AF_INET, SOCK_DGRAM, 0);
+	s = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, 0);
 	if (s >= 0) {
 #ifdef __FreeBSD__
 		/*
@@ -745,7 +745,7 @@ pcap_lookupnet(device, netp, maskp, errb
 		return 0;
 	}
 
-	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	fd = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, 0);
 	if (fd < 0) {
 		(void)snprintf(errbuf, PCAP_ERRBUF_SIZE, "socket: %s",
 		    pcap_strerror(errno));
--- pcap-netfilter-linux.c.orig
+++ pcap-netfilter-linux.c
@@ -363,7 +363,7 @@ nflog_activate(pcap_t* handle)
 	handle->stats_op = netfilter_stats_linux;
 
 	/* Create netlink socket */
-	handle->fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);
+	handle->fd = socket(AF_NETLINK, SOCK_RAW|SOCK_CLOEXEC, NETLINK_NETFILTER);
 	if (handle->fd < 0) {
 		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, "Can't create raw socket %d:%s", errno, pcap_strerror(errno));
 		return PCAP_ERROR;
@@ -450,7 +450,7 @@ netfilter_platform_finddevs(pcap_if_t **
 	pcap_if_t *found_dev = *alldevsp;
 	int sock;
 	
-	sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);
+	sock = socket(AF_NETLINK, SOCK_RAW|SOCK_CLOEXEC, NETLINK_NETFILTER);
 	if (sock < 0) {
 		/* if netlink is not supported this is not fatal */
 		if (errno == EAFNOSUPPORT || errno == EPROTONOSUPPORT)
--- savefile.c.orig
+++ savefile.c
@@ -189,7 +189,7 @@ pcap_open_offline(const char *fname, cha
 	}
 	else {
 #if !defined(WIN32) && !defined(MSDOS)
-		fp = fopen(fname, "r");
+		fp = fopen(fname, "re");
 #else
 		fp = fopen(fname, "rb");
 #endif
--- pcap-snit.c.orig
+++ pcap-snit.c
@@ -297,9 +297,9 @@ pcap_activate_snit(pcap_t *p)
 	 * the device in question) can be indicated at open
 	 * time.
 	 */
-	p->fd = fd = open(dev, O_RDWR);
+	p->fd = fd = open(dev, O_RDWR|O_CLOEXEC);
 	if (fd < 0 && errno == EACCES)
-		p->fd = fd = open(dev, O_RDONLY);
+		p->fd = fd = open(dev, O_RDONLY|O_CLOEXEC);
 	if (fd < 0) {
 		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "%s: %s", dev,
 		    pcap_strerror(errno));
--- fad-glifc.c.orig
+++ fad-glifc.c
@@ -100,7 +100,7 @@ pcap_findalldevs(pcap_if_t **alldevsp, c
 	 * Create a socket from which to fetch the list of interfaces,
 	 * and from which to fetch IPv4 information.
 	 */
-	fd4 = socket(AF_INET, SOCK_DGRAM, 0);
+	fd4 = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, 0);
 	if (fd4 < 0) {
 		(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    "socket: %s", pcap_strerror(errno));
@@ -110,7 +110,7 @@ pcap_findalldevs(pcap_if_t **alldevsp, c
 	/*
 	 * Create a socket from which to fetch IPv6 information.
 	 */
-	fd6 = socket(AF_INET6, SOCK_DGRAM, 0);
+	fd6 = socket(AF_INET6, SOCK_DGRAM|SOCK_CLOEXEC, 0);
 	if (fd6 < 0) {
 		(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    "socket: %s", pcap_strerror(errno));
--- pcap-nit.c.orig
+++ pcap-nit.c
@@ -259,7 +259,7 @@ pcap_activate_nit(pcap_t *p)
 		p->snapshot = 96;
 
 	memset(p, 0, sizeof(*p));
-	p->fd = fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW);
+	p->fd = fd = socket(AF_NIT, SOCK_RAW|SOCK_CLOEXEC, NITPROTO_RAW);
 	if (fd < 0) {
 		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
 		    "socket: %s", pcap_strerror(errno));
--- pcap-sita.c.orig
+++ pcap-sita.c
@@ -318,7 +318,7 @@ static int open_with_IOP(unit_t  *u, int
 	u->serv_addr->sin_addr.s_addr	= inet_addr(ip);
 	u->serv_addr->sin_port			= htons(IOP_SNIFFER_PORT);
 
-	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+	if ((sockfd = socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, 0)) < 0) {
 		fprintf(stderr, "pcap can't open a socket for connecting to IOP at %s\n", ip);
 		return 0;
 	}
--- pcap-can-linux.c.orig
+++ pcap-can-linux.c
@@ -106,7 +106,7 @@ can_activate(pcap_t* handle)
 	handle->stats_op = can_stats_linux;
 
 	/* Create socket */
-	handle->fd = socket(PF_CAN, SOCK_RAW, CAN_RAW);
+	handle->fd = socket(PF_CAN, SOCK_RAW|SOCK_CLOEXEC, CAN_RAW);
 	if (handle->fd < 0)
 	{
 		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, "Can't create raw socket %d:%s",
@@ -180,7 +180,7 @@ can_read_linux(pcap_t *handle, int max_p
 
 	do
 	{
-		pkth.caplen = recvmsg(handle->fd, &msg, 0);
+		pkth.caplen = recvmsg(handle->fd, &msg, MSG_CMSG_CLOEXEC);
 		if (handle->break_loop)
 		{
 			handle->break_loop = 0;
--- fad-gifc.c.orig
+++ fad-gifc.c
@@ -156,7 +156,7 @@ pcap_findalldevs(pcap_if_t **alldevsp, c
 	/*
 	 * Create a socket from which to fetch the list of interfaces.
 	 */
-	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	fd = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC, 0);
 	if (fd < 0) {
 		(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    "socket: %s", pcap_strerror(errno));
--- nametoaddr.c.orig
+++ nametoaddr.c
@@ -440,7 +440,7 @@ pcap_ether_hostton(const char *name)
 	static int init = 0;
 
 	if (!init) {
-		fp = fopen(PCAP_ETHERS_FILE, "r");
+		fp = fopen(PCAP_ETHERS_FILE, "re");
 		++init;
 		if (fp == NULL)
 			return (NULL);
--- pcap-usb-linux.c.orig
+++ pcap-usb-linux.c
@@ -252,7 +252,7 @@ probe_devices(int bus)
 
 		snprintf(buf, sizeof(buf), "/dev/bus/usb/%03d/%s", bus, data->d_name);
 		
-		fd = open(buf, O_RDWR);
+		fd = open(buf, O_RDWR|O_CLOEXEC);
 		if (fd == -1)
 			continue;
 
@@ -323,7 +323,7 @@ usb_activate(pcap_t* handle)
 
 	/*now select the read method: try to open binary interface */
 	snprintf(full_path, USB_LINE_LEN, LINUX_USB_MON_DEV"%d", handle->md.ifindex);  
-	handle->fd = open(full_path, O_RDONLY, 0);
+	handle->fd = open(full_path, O_RDONLY|O_CLOEXEC, 0);
 	if (handle->fd >= 0)
 	{
 		if (handle->opt.rfmon) {
@@ -358,7 +358,7 @@ usb_activate(pcap_t* handle)
 	else {
 		/*Binary interface not available, try open text interface */
 		snprintf(full_path, USB_LINE_LEN, USB_TEXT_DIR"/%dt", handle->md.ifindex);  
-		handle->fd = open(full_path, O_RDONLY, 0);
+		handle->fd = open(full_path, O_RDONLY|O_CLOEXEC, 0);
 		if (handle->fd < 0)
 		{
 			if (errno == ENOENT)
@@ -368,7 +368,7 @@ usb_activate(pcap_t* handle)
 				 * the old location.
 				 */
 				snprintf(full_path, USB_LINE_LEN, USB_TEXT_DIR_OLD"/%dt", handle->md.ifindex);  
-				handle->fd = open(full_path, O_RDONLY, 0);
+				handle->fd = open(full_path, O_RDONLY|O_CLOEXEC, 0);
 			}
 			if (handle->fd < 0) {
 				/* no more fallback, give it up*/
@@ -634,7 +634,7 @@ usb_stats_linux(pcap_t *handle, struct p
 	int fd;
 
 	snprintf(string, USB_LINE_LEN, USB_TEXT_DIR"/%ds", handle->md.ifindex);
-	fd = open(string, O_RDONLY, 0);
+	fd = open(string, O_RDONLY|O_CLOEXEC, 0);
 	if (fd < 0)
 	{
 		if (errno == ENOENT)
@@ -644,7 +644,7 @@ usb_stats_linux(pcap_t *handle, struct p
 			 * location.
 			 */
 			snprintf(string, USB_LINE_LEN, USB_TEXT_DIR_OLD"/%ds", handle->md.ifindex);
-			fd = open(string, O_RDONLY, 0);
+			fd = open(string, O_RDONLY|O_CLOEXEC, 0);
 		}
 		if (fd < 0) {
 			snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
--- pcap-snoop.c.orig
+++ pcap-snoop.c
@@ -205,7 +205,7 @@ pcap_activate_snoop(pcap_t *p)
 	int snooplen;
 	struct ifreq ifr;
 
-	fd = socket(PF_RAW, SOCK_RAW, RAWPROTO_SNOOP);
+	fd = socket(PF_RAW, SOCK_RAW|SOCK_CLOEXEC, RAWPROTO_SNOOP);
 	if (fd < 0) {
 		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "snoop socket: %s",
 		    pcap_strerror(errno));
--- pcap-bt-linux.c.orig
+++ pcap-bt-linux.c
@@ -79,7 +79,7 @@ bt_platform_finddevs(pcap_if_t **alldevs
 	int i, sock;
 	int ret = 0;
 	
-	sock  = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
+	sock  = socket(AF_BLUETOOTH, SOCK_RAW|SOCK_CLOEXEC, BTPROTO_HCI);
 	if (sock < 0)
 	{
 		/* if bluetooth is not supported this this is not fatal*/ 
@@ -181,7 +181,7 @@ bt_activate(pcap_t* handle)
 	handle->md.ifindex = dev_id;
 	
 	/* Create HCI socket */
-	handle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);
+	handle->fd = socket(AF_BLUETOOTH, SOCK_RAW|SOCK_CLOEXEC, BTPROTO_HCI);
 	if (handle->fd < 0) {
 		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
 		    "Can't create raw socket: %s", strerror(errno));
@@ -282,7 +282,7 @@ bt_read_linux(pcap_t *handle, int max_pa
 
 	/* ignore interrupt system call error */
 	do {
-		ret = recvmsg(handle->fd, &msg, 0);
+		ret = recvmsg(handle->fd, &msg, MSG_CMSG_CLOEXEC);
 		if (handle->break_loop)
 		{
 			handle->break_loop = 0;
